打折日期交叉问题

如下为平台商品促销数据: 字段为品牌, 打折开始日期, 打折结束日期
id 		stt 		edt
oppo	2021-06-05	2021-06-09
oppo	2021-06-11	2021-06-21
vivo	2021-06-05	2021-06-15
vivo	2021-06-09	2021-06-21
redmi	2021-06-05	2021-06-21
redmi	2021-06-09	2021-06-15
redmi	2021-06-17	2021-06-26
huawei	2021-06-05	2021-06-26
huawei	2021-06-09	2021-06-15
huawei	2021-06-17	2021-06-21

计算每个品牌总的打折销售天数, 注意其中的交叉日期,
比如 vivo 品牌, 第一次活动时间为 2021-06-05 到 2021-06-15,
第二次活动时间为 2021-06-09 到 2021-06-21 其中 9 号到 15 号为重复天数, 只统计一次,
即 vivo 总打折天数为 2021-06-05 到 2021-06-21 共计 17 天

分析:
题意要求某品牌总的打折天数, 有两种情景需要考虑:

情景一: 两次活动的日期没有交叉, 如OPPO的两次活动:
id      stt         edt
oppo 2021-06-05 2021-06-09
oppo 2021-06-11 2021-06-21
对于这种情况, 我们直接分别求diff再做sum即可, 即(edt-stt+1):
id      stt         edt        diff
oppo 2021-06-05 2021-06-09       5
oppo 2021-06-11 2021-06-21       11
再按照 id 分组求sum(diff)=16天

情景二: 两次活动的日期有交叉, 如vivo的两次活动:
id      stt         edt
vivo 2021-06-05 2021-06-15
vivo 2021-06-09 2021-06-21
第一次活动时间为[2021-06-05, 2021-06-15], 第二次活动时间为 [2021-06-09, 2021-06-21] 其中 9 号到 15 号为重复天数,
只统计一次, 即 vivo 总打折天数为 [2021-06-05, 2021-06-21] 共计 17 天
如果不考虑交叉, 仍然按照情景一的方式计算, 两段活动日期的diff分别为: 11 和 13, 加起来是24天, 如何将中间重复的天数只计算一次呢?
注意观察: 出现日期交叉的原因是因为第二次活动的开始时间小于第一次活动的结束时间, 换句话说, 第一次活动还没结束第二次活动就开始了
换个角度思考: 如果第二次活动在第一次活动结束后再开始, 就不会出现日期交叉了, 我们试试将第二次活动的开始时间改为第一次活动结束+1看看会是什么样:
-- 2021-06-09 改成 2021-06-16
id      stt         edt
vivo 2021-06-05 2021-06-15
vivo 2021-06-16 2021-06-21
我们再用情景一的计算方式计算出来, 活动天数为: 11+6=17, 符合题意
通过这样的转换, 就能将交叉重复的日期只计算一次, 所以到此可以总结为: 在计算时, 先将本次活动的起始时间改为上次活动的结束时间+1,
再分别做diff再求和即可, 这样我们就可以用lag()或者lead()将edt字段下移做计算

但这样真的可以吗?会存在一个问题, 看个redmi例子:
-- 原数据(人工计算出来的天数应该是22天)：
id      stt         edt
redmi 2021-06-05 2021-06-21
redmi 2021-06-09 2021-06-15
redmi 2021-06-17 2021-06-26
-- 按照分析，将"本次"活动的开始时间改为"上次"活动的结束时间+1：
id      stt         edt       edt下移                             diff(edt-stt+1)
redmi 2021-06-05 2021-06-21 1970-01-01 --不变                       21-5+1=17
redmi 2021-06-09 2021-06-15 2021-06-21 --2021-06-09改为2021-06-22   15-22+1= -6
redmi 2021-06-17 2021-06-26 2021-06-15 --2021-06-17改为2021-06-16   26-16+1= 11

会发现, 有负数出现, 但这个无关紧要, 在做sum时会过滤掉 <0 的天数
非负数求和加起来是28天, 跟真实的22天不符
问题出在第三行, 2021-06-17 改为 2021-06-16, 其实第三行的开始时间应该改成第三行前面活动的最大结束时间+1, 即改成 2021-06-22 即可
所以, 前面的总结需要修改一下: 在计算时, 先将本次活动的起始时间改为前几次活动的最大结束时间+1, 再分别做diff再求和即可

with promotion as (
    select
        'oppo' as id,
        '2021-06-05' as stt,
        '2021-06-09' as ent
    union all
    select
        'oppo' as id,
        '2021-06-11' as stt,
        '2021-06-21' as ent
    union all
    select
        'vivo' as id,
        '2021-06-05' as stt,
        '2021-06-15' as ent
    union all
    select
        'vivo' as id,
        '2021-06-09' as stt,
        '2021-06-21' as ent
    union all
    select
        'redmi' as id,
        '2021-06-05' as stt,
        '2021-06-21' as ent
    union all
    select
        'redmi' as id,
        '2021-06-09' as stt,
        '2021-06-15' as ent
    union all
    select
        'redmi' as id,
        '2021-06-17' as stt,
        '2021-06-26' as ent
    union all
    select
        'huawei' as id,
        '2021-06-05' as stt,
        '2021-06-26' as ent
    union all
    select
        'huawei' as id,
        '2021-06-09' as stt,
        '2021-06-15' as ent
    union all
    select
        'huawei' as id,
        '2021-06-17' as stt,
        '2021-06-21' as ent
), promotion_temp as (
    select
        id,
        if(max_ent is null, stt, if(stt > max_ent, stt, date_add(max_ent, 1))) as stt_temp,
        ent
    from
        (
            select
                id,
                stt,
                ent,
                max(ent) over(partition by id order by stt rows between unbounded preceding and 1 preceding) as max_ent --以开始时间排序
                --max(ent) over(partition by id order by ent rows between unbounded preceding and 1 preceding) as max_ent2 两者结果不一样
            from promotion
        ) t1
)
select
    id,
    sum(ct + 1) as res
from
    (
        select
            id,
            datediff(ent, stt_temp) as ct
        from promotion_temp
    ) t1
where ct >= 0
group by id



    +------+----------+----------+----------+----------+
    |    id|       stt|       ent|   max_ent|  max_ent2|
    +------+----------+----------+----------+----------+
    |huawei|2021-06-05|2021-06-26|      null|2021-06-21|
    |huawei|2021-06-09|2021-06-15|2021-06-26|      null|
    |huawei|2021-06-17|2021-06-21|2021-06-26|2021-06-15|
    |  oppo|2021-06-05|2021-06-09|      null|      null|
    |  oppo|2021-06-11|2021-06-21|2021-06-09|2021-06-09|
    | redmi|2021-06-05|2021-06-21|      null|2021-06-15|
    | redmi|2021-06-09|2021-06-15|2021-06-21|      null|
    | redmi|2021-06-17|2021-06-26|2021-06-21|2021-06-21|
    |  vivo|2021-06-05|2021-06-15|      null|      null|
    |  vivo|2021-06-09|2021-06-21|2021-06-15|2021-06-15|
    +------+----------+----------+----------+----------+




